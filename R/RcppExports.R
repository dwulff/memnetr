# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

count_assos_directed <- function(cues, responses) {
    .Call('_memnetr_count_assos_directed', PACKAGE = 'memnetr', cues, responses)
}

count_assos_undirected <- function(cues, responses) {
    .Call('_memnetr_count_assos_undirected', PACKAGE = 'memnetr', cues, responses)
}

determine_indices <- function(words) {
    .Call('_memnetr_determine_indices', PACKAGE = 'memnetr', words)
}

get_A <- function(cues, responses) {
    .Call('_memnetr_get_A', PACKAGE = 'memnetr', cues, responses)
}

rowsums <- function(A) {
    .Call('_memnetr_rowsums', PACKAGE = 'memnetr', A)
}

colsums <- function(A) {
    .Call('_memnetr_colsums', PACKAGE = 'memnetr', A)
}

P_from_A <- function(A) {
    .Call('_memnetr_P_from_A', PACKAGE = 'memnetr', A)
}

PPMI_from_P <- function(P) {
    .Call('_memnetr_PPMI_from_P', PACKAGE = 'memnetr', P)
}

get_P <- function(cues, responses) {
    .Call('_memnetr_get_P', PACKAGE = 'memnetr', cues, responses)
}

get_PPMI <- function(cues, responses) {
    .Call('_memnetr_get_PPMI', PACKAGE = 'memnetr', cues, responses)
}

get_cosines <- function(A) {
    .Call('_memnetr_get_cosines', PACKAGE = 'memnetr', A)
}

normalize <- function(vec) {
    .Call('_memnetr_normalize', PACKAGE = 'memnetr', vec)
}

chunk <- function(a, b) {
    .Call('_memnetr_chunk', PACKAGE = 'memnetr', a, b)
}

chunk_norm <- function(a, b) {
    .Call('_memnetr_chunk_norm', PACKAGE = 'memnetr', a, b)
}

make_word <- function(k) {
    .Call('_memnetr_make_word', PACKAGE = 'memnetr', k)
}

split_string_list <- function(sents, indices) {
    .Call('_memnetr_split_string_list', PACKAGE = 'memnetr', sents, indices)
}

beagle_basis <- function(sents, indices, targets) {
    .Call('_memnetr_beagle_basis', PACKAGE = 'memnetr', sents, indices, targets)
}

beagle_basis_stops <- function(sents, indices, targets, stops) {
    .Call('_memnetr_beagle_basis_stops', PACKAGE = 'memnetr', sents, indices, targets, stops)
}

beagle_con <- function(sents, indices, n_target, d = 1000L, missing = TRUE) {
    .Call('_memnetr_beagle_con', PACKAGE = 'memnetr', sents, indices, n_target, d, missing)
}

cosine <- function(a, b) {
    .Call('_memnetr_cosine', PACKAGE = 'memnetr', a, b)
}

cosine_mat <- function(representation) {
    .Call('_memnetr_cosine_mat', PACKAGE = 'memnetr', representation)
}

upper_mat <- function(mat) {
    .Call('_memnetr_upper_mat', PACKAGE = 'memnetr', mat)
}

seed <- function(n, m) {
    .Call('_memnetr_seed', PACKAGE = 'memnetr', n, m)
}

sm <- function(x) {
    .Call('_memnetr_sm', PACKAGE = 'memnetr', x)
}

getdegrees <- function(adj, pos) {
    .Call('_memnetr_getdegrees', PACKAGE = 'memnetr', adj, pos)
}

getnonneighbors <- function(adj, node) {
    .Call('_memnetr_getnonneighbors', PACKAGE = 'memnetr', adj, node)
}

selectnode <- function(ps) {
    .Call('_memnetr_selectnode', PACKAGE = 'memnetr', ps)
}

stgame <- function(n, m) {
    .Call('_memnetr_stgame', PACKAGE = 'memnetr', n, m)
}

emptyseed <- function(n) {
    .Call('_memnetr_emptyseed', PACKAGE = 'memnetr', n)
}

puni <- function() {
    .Call('_memnetr_puni', PACKAGE = 'memnetr')
}

unconnectedneighbor <- function(adj, from, to) {
    .Call('_memnetr_unconnectedneighbor', PACKAGE = 'memnetr', adj, from, to)
}

test <- function(n = 100L, m = 5L) {
    invisible(.Call('_memnetr_test', PACKAGE = 'memnetr', n, m))
}

hkgame <- function(n, m, p) {
    .Call('_memnetr_hkgame', PACKAGE = 'memnetr', n, m, p)
}

set <- function(v) {
    .Call('_memnetr_set', PACKAGE = 'memnetr', v)
}

mset <- function(dat) {
    .Call('_memnetr_mset', PACKAGE = 'memnetr', dat)
}

indx <- function(s, set) {
    .Call('_memnetr_indx', PACKAGE = 'memnetr', s, set)
}

lags <- function(dat, l, na_rm = TRUE) {
    .Call('_memnetr_lags', PACKAGE = 'memnetr', dat, l, na_rm)
}

strsplit <- function(s, delim) {
    .Call('_memnetr_strsplit', PACKAGE = 'memnetr', s, delim)
}

getinds <- function(pairs, unis) {
    .Call('_memnetr_getinds', PACKAGE = 'memnetr', pairs, unis)
}

getpairs <- function(spairs, del) {
    .Call('_memnetr_getpairs', PACKAGE = 'memnetr', spairs, del)
}

count <- function(v) {
    .Call('_memnetr_count', PACKAGE = 'memnetr', v)
}

range <- function(n) {
    .Call('_memnetr_range', PACKAGE = 'memnetr', n)
}

get_indices <- function(n, use) {
    .Call('_memnetr_get_indices', PACKAGE = 'memnetr', n, use)
}

cut_stringvec <- function(items, indices) {
    .Call('_memnetr_cut_stringvec', PACKAGE = 'memnetr', items, indices)
}

cut_dat <- function(dat, inds, indices) {
    .Call('_memnetr_cut_dat', PACKAGE = 'memnetr', dat, inds, indices)
}

mcount <- function(dat) {
    .Call('_memnetr_mcount', PACKAGE = 'memnetr', dat)
}

getprob <- function(counts, N) {
    .Call('_memnetr_getprob', PACKAGE = 'memnetr', counts, N)
}

pinwin <- function(n, l) {
    .Call('_memnetr_pinwin', PACKAGE = 'memnetr', n, l)
}

mpinwin <- function(ns, l) {
    .Call('_memnetr_mpinwin', PACKAGE = 'memnetr', ns, l)
}

lens <- function(dat) {
    .Call('_memnetr_lens', PACKAGE = 'memnetr', dat)
}

mlength <- function(dat) {
    .Call('_memnetr_mlength', PACKAGE = 'memnetr', dat)
}

getplink <- function(inds, probs, pinwin) {
    .Call('_memnetr_getplink', PACKAGE = 'memnetr', inds, probs, pinwin)
}

dbinom <- function(k, n, p) {
    .Call('_memnetr_dbinom', PACKAGE = 'memnetr', k, n, p)
}

pbinom <- function(k, n, p) {
    .Call('_memnetr_pbinom', PACKAGE = 'memnetr', k, n, p)
}

#' Create Goni graph
#'
#' Creare Goni graph from verbal fluency data. Function creates a graph
#' by adding edges for words that occur within a window size \code{l}
#' more frequently than \code{min_cooc} and \code{100(1-crit)%} of
#' chance productions.
#'
#'
#' @param dat
#' @param l an integer specifying the window size. The internal upper limit
#'   of \code{l} is the number of productions.
#' @param crit a numeric within \code{[0,1]} specifiying the type-1 error
#'   rate of including an edge between unconnected words.
#' @param min_cooc integer specifying the minimum number of times two words
#'   have to coocur within a window size of \code{l} to consider including
#'   an edge between them.
#'
#' @return
#' A matrix
#'
goni_graph <- function(dat, l = 3L, min_cooc = 1L, crit = .05, use = 10000L) {
    .Call('_memnetr_goni_graph', PACKAGE = 'memnetr', dat, l, min_cooc, crit, use)
}

#' Create random walk graph
#'
#' Creare random walk graph from verbal fluency data. Function creates a graph
#' by adding edges for words that occur within a window size of 1.
#'
#' @param dat
#'
#' @return
#' A matrix
#'
rw_graph <- function(dat) {
    .Call('_memnetr_rw_graph', PACKAGE = 'memnetr', dat)
}

unique_int <- function(v) {
    .Call('_memnetr_unique_int', PACKAGE = 'memnetr', v)
}

rint <- function(n) {
    .Call('_memnetr_rint', PACKAGE = 'memnetr', n)
}

runi <- function() {
    .Call('_memnetr_runi', PACKAGE = 'memnetr')
}

#' Get adjacency list
#'
#' Get list containing adjacent vertices for each vertex in the graph.
#'
#' Adjacent vertices are returned in terms of their row index of the adjacency matrix.
#'
#' @param adj numeric matrix specifying the adjacency matrix.
#'
#' @return A list of vectors containing the indices of adjacent vertices.
#'
#' @export
get_adjlist <- function(adj) {
    .Call('_memnetr_get_adjlist', PACKAGE = 'memnetr', adj)
}

#' Get neighbors k or fewer steps away
#'
#' Function iterates over graph to identify for a given vertex all vertices that are
#' no more than k steps apart.
#'
#' k = 0 will return be interpreted as k = 1.
#'
#' @param adj numeric matrix specifying the adjacency matrix.
#' @param start integer specifying the row of the start vertex in the adjacency matrix.
#' @param k integer specifying the maximum distance to the start vertex.
#'
#' @return A character vector containing vertices \code{k} or fewer steps away
#' from \code{start}.
#'
#' @export
get_neighborhood <- function(adj, start, k) {
    .Call('_memnetr_get_neighborhood', PACKAGE = 'memnetr', adj, start, k)
}

#' Get vector of neighbors exactly k steps away
#'
#' Function iterates over graph to identify for a given vertex all vertices that are
#' exactly k steps apart.
#'
#' k = 0 will return be interpreted as k = 1.
#'
#' @param adj numeric matrix specifying the adjacency matrix.
#' @param start integer specifying the row of the start vertex in the adjacency matrix.
#' @param k integer specifying the exact distance to the start vertex.
#'
#' @return A character vector containing vertices \code{k} or fewer steps away
#' from \code{start}.
#'
#' @export
get_kneighbor <- function(adj, start, k) {
    .Call('_memnetr_get_kneighbor', PACKAGE = 'memnetr', adj, start, k)
}

tostring <- function(items) {
    .Call('_memnetr_tostring', PACKAGE = 'memnetr', items)
}

m_nn <- function(ele, set, rep) {
    .Call('_memnetr_m_nn', PACKAGE = 'memnetr', ele, set, rep)
}

m_nc <- function(ele, set, rep) {
    .Call('_memnetr_m_nc', PACKAGE = 'memnetr', ele, set, rep)
}

m_cn <- function(ele, set, rep) {
    .Call('_memnetr_m_cn', PACKAGE = 'memnetr', ele, set, rep)
}

m_cc <- function(ele, set, rep) {
    .Call('_memnetr_m_cc', PACKAGE = 'memnetr', ele, set, rep)
}

match_nn <- function(elems, set, rep) {
    .Call('_memnetr_match_nn', PACKAGE = 'memnetr', elems, set, rep)
}

match_nc <- function(elems, set, rep) {
    .Call('_memnetr_match_nc', PACKAGE = 'memnetr', elems, set, rep)
}

match_cn <- function(elems, set, rep) {
    .Call('_memnetr_match_cn', PACKAGE = 'memnetr', elems, set, rep)
}

match_cc <- function(elems, set, rep) {
    .Call('_memnetr_match_cc', PACKAGE = 'memnetr', elems, set, rep)
}

read_texts <- function(paths) {
    .Call('_memnetr_read_texts', PACKAGE = 'memnetr', paths)
}

reads_texts_remove <- function(paths, patterns) {
    .Call('_memnetr_reads_texts_remove', PACKAGE = 'memnetr', paths, patterns)
}

upper_mat_ <- function(mat) {
    .Call('_memnetr_upper_mat_', PACKAGE = 'memnetr', mat)
}

serialize_tt <- function(tt_mat, include_diag = TRUE) {
    .Call('_memnetr_serialize_tt', PACKAGE = 'memnetr', tt_mat, include_diag)
}

serialize_td <- function(td_mat, add_context = FALSE) {
    .Call('_memnetr_serialize_td', PACKAGE = 'memnetr', td_mat, add_context)
}

rescorla_wagner <- function(td_mat, include_context = TRUE, scramble_order = TRUE, gamma = 0.01, lambda = 1, start = 0) {
    .Call('_memnetr_rescorla_wagner', PACKAGE = 'memnetr', td_mat, include_context, scramble_order, gamma, lambda, start)
}

noverk <- function(n, k) {
    .Call('_memnetr_noverk', PACKAGE = 'memnetr', n, k)
}

getneighbors <- function(adjlist, pos) {
    .Call('_memnetr_getneighbors', PACKAGE = 'memnetr', adjlist, pos)
}

getnext <- function(neighbors) {
    .Call('_memnetr_getnext', PACKAGE = 'memnetr', neighbors)
}

unicut <- function(vs, n) {
    .Call('_memnetr_unicut', PACKAGE = 'memnetr', vs, n)
}

#' Verbal fluency generator
#'
#' Generates verbal fluency data using a switcher-random walk process.
#'
#' Function produces verbal fluency data via a switcher random walk
#' process that traverses the network by selecting a neighbor with
#' probability 1-\code{pjump} or jumps to a random place in the network
#' with probability \code{pjump}. Where the random walk process enters
#' the network and where it jumps to is additionally controlled
#' by \code{type}. Neighbors are always selected uniformly.
#'
#' @param adjlist a list containing row indices for adjacent vertices as created
#'   by \link{get_adjlist}.
#' @param n integer specifying the number of productions.
#' @param pjump numeric specifying the probability of a jump.
#' @param type integer controlling network start and jump vertices.
#'   For \code{type = 0} the process selects the start vertex and any jump
#'   vertices proportional to their degree. For \code{type = 1} the process
#'   selects a random vertex to serve as the start vertex and the jump vertex.
#'   For \code{type = 2} the process selects the start and any jump vertices
#'   uniformly.
#'
#' @return Integer vector containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
fluency <- function(adjlist, n, pjump, type) {
    .Call('_memnetr_fluency', PACKAGE = 'memnetr', adjlist, n, pjump, type)
}

#' Verbal fluency generator wrapper
#'
#' Generates multiple verbal fluency sequences using \code{fluency}.
#'
#' For details see \link{fluency}.
#'
#' @inheritParams fluency
#'
#' @return List of character vectors containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
mfluency <- function(adjlist, n, pjump = 0, type = 1L) {
    .Call('_memnetr_mfluency', PACKAGE = 'memnetr', adjlist, n, pjump, type)
}

#' Fast verbal fluency generator
#'
#' Generates verbal fluency data using a switcher-random walk process.
#'
#' Function produces verbal fluency data via a switcher random walk
#' process that traverses the network by selecting neighbors with
#' probability 1-\code{pjump} or jumps to a random place in the network
#' with probability \code{pjump}. How the random walk process enters
#' the network and how it jumps to is additionally controlled
#' by \code{random}. Neighbors are always selected uniformly.
#'
#' In contrast to \link{fluency}, does not check at every step whether
#' the sampled neighbor is already in the list of productions. Instead
#' \code{ffluency} simply returns the list of unique productions. This means
#' that if repetitions occur \code{ffluency} will produce sequences of length
#' \code{min(n*3 - k, n)} where k is the number of repeptitions.
#'
#' @inheritParams fluency
#' @param n integer specifying the number of productions.
#' @param random bool controlling jump vertices.
#'   For \code{random = TRUE} the process selects jump at random. For
#'   \code{random = FALSE} the process always jumps back to the start vertex. The
#'   start vertex is always selected at random.
#'
#'
#' @return Integer vector containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
ffluency <- function(adjlist, n, pjump, random, pref_start = FALSE) {
    .Call('_memnetr_ffluency', PACKAGE = 'memnetr', adjlist, n, pjump, random, pref_start)
}

#' Fast verbal fluency generator wrapper
#'
#' Generates multiple verbal fluency sequences using \code{fluency}.
#'
#' For details see \link{ffluency}.
#'
#' @inheritParams ffluency
#'
#' @return List of character vectors containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
mfsearch <- function(adjlist, n, pjump = 0, random = FALSE, pref_start = FALSE) {
    .Call('_memnetr_mfsearch', PACKAGE = 'memnetr', adjlist, n, pjump, random, pref_start)
}

#' Exhaustive verbal fluency generator
#'
#' Generates verbal fluency data using a switcher-random walk process.
#'
#' Function produces verbal fluency data via a switcher random walk
#' process that traverses the network by selecting neighbors with
#' probability 1-\code{pjump} or jumps to a random place in the network
#' with probability \code{pjump}. How the random walk process enters
#' the network and how it jumps to is additionally controlled
#' by \code{random}. Neighbors are always selected uniformly.
#'
#' In contrast to \link{fluency}, does not check at every step whether
#' the sampled neighbor is already in the list of productions. Instead
#' \code{ffluency} simply returns the list of unique productions. This means
#' that if repetitions occur \code{ffluency} will produce sequences of length
#' \code{min(n*3 - k, n)} where k is the number of repeptitions.
#'
#' @inheritParams fluency
#' @param n integer specifying the number of productions.
#' @param random bool controlling jump vertices.
#'   For \code{random = TRUE} the process selects jump at random. For
#'   \code{random = FALSE} the process always jumps back to the start vertex. The
#'   start vertex is always selected at random.
#'
#'
#' @return Integer vector containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
efluency <- function(adjlist, n, pjump, random, pref_start = FALSE) {
    .Call('_memnetr_efluency', PACKAGE = 'memnetr', adjlist, n, pjump, random, pref_start)
}

#' Verbal fluency generator wrapper
#'
#' Generates multiple verbal fluency sequences using \code{efluency}.
#'
#' For details see \link{efluency}.
#'
#' @inheritParams efluency
#'
#' @return List of character vectors containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
mesearch <- function(adjlist, n, pjump = 0, random = FALSE, pref_start = FALSE) {
    .Call('_memnetr_mesearch', PACKAGE = 'memnetr', adjlist, n, pjump, random, pref_start)
}

#' Verbal fluency step counter
#'
#' Generates verbal fluency data using a switcher-random walk process.
#'
#' Function produces verbal fluency data via a switcher random walk
#' process that traverses the network by selecting neighbors with
#' probability 1-\code{pjump} or jumps to a random place in the network
#' with probability \code{pjump}. How the random walk process enters
#' the network and how it jumps to is additionally controlled
#' by \code{random}. Neighbors are always selected uniformly.
#'
#' In contrast to \link{fluency}, does not check at every step whether
#' the sampled neighbor is already in the list of productions. Instead
#' \code{ffluency} simply returns the list of unique productions. This means
#' that if repetitions occur \code{ffluency} will produce sequences of length
#' \code{min(n*3 - k, n)} where k is the number of repeptitions.
#'
#' @inheritParams fluency
#' @param n integer specifying the number of productions.
#' @param random bool controlling jump vertices.
#'   For \code{random = TRUE} the process selects jump at random. For
#'   \code{random = FALSE} the process always jumps back to the start vertex. The
#'   start vertex is always selected at random.
#'
#'
#' @return Integer vector containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
sfluency <- function(adjlist, n, pjump, random, pref_start = FALSE) {
    .Call('_memnetr_sfluency', PACKAGE = 'memnetr', adjlist, n, pjump, random, pref_start)
}

#' Exhaustive verbal fluency generator wrapper
#'
#' Generates multiple verbal fluency sequences using \code{efluency}.
#'
#' For details see \link{efluency}.
#'
#' @inheritParams efluency
#'
#' @return List of character vectors containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
mssearch <- function(adjlist, n, pjump = 0, random = FALSE, pref_start = FALSE) {
    .Call('_memnetr_mssearch', PACKAGE = 'memnetr', adjlist, n, pjump, random, pref_start)
}

#' Random walk
#'
#' Traverses a network using a switcher-random walk process and records the earliest
#' visit to vertices of interest.
#'
#' Beginning at a given start vertext, function traverses a network using switcher
#' random walk and records for each of a list of vertices of interest the index at which
#' the respective vertices have been visited first.
#'
#' If a vertex specified in \code{observe} has never been visited then the function
#' returns \code{nmax} for that vertex.
#'
#' @inheritParams fluency
#' @param start index of the start vertix.
#' @param observe integer vector specifying the vertices whose first visits should be recorded.
#' @param nmax integer specifying the maximum number of steps.
#'
#' @return Numeric, 3 column matrix containing in each row the start vertex, the end vertex, and
#' the (minimum) number of steps it took to reach the end vertext from the start vertex.
#'
#' @export
rwalk <- function(adjlist, start, observe, nmax = 1000L, pjump = 0) {
    .Call('_memnetr_rwalk', PACKAGE = 'memnetr', adjlist, start, observe, nmax, pjump)
}

#' Random walk
#'
#' Traverses a network using a switcher-random walk process and records the earliest
#' visit to vertices of interest.
#'
#' Beginning at a given start vertext, function traverses a network using switcher
#' random walk and records for each of a list of vertices of interest the index at which
#' the respective vertices have been visited first.
#'
#' If a vertex specified in \code{observe} has never been visited then the function
#' returns \code{nmax} for that vertex.
#'
#' @inheritParams fluency
#' @param start index of the start vertix.
#' @param observe integer vector specifying the vertices whose first visits should be recorded.
#' @param nmax integer specifying the maximum number of steps.
#'
#' @return Numeric, 3 column matrix containing in each row the start vertex, the end vertex, and
#' the (minimum) number of steps it took to reach the end vertext from the start vertex.
#'
#' @export
mrwalk <- function(adjlist, start, observe, nrep = 100L, aggregate = TRUE, nmax = 1000L, pjump = 0) {
    .Call('_memnetr_mrwalk', PACKAGE = 'memnetr', adjlist, start, observe, nrep, aggregate, nmax, pjump)
}

staSearch <- function(x) {
    .Call('_memnetr_staSearch', PACKAGE = 'memnetr', x)
}

dynSearch <- function(x) {
    .Call('_memnetr_dynSearch', PACKAGE = 'memnetr', x)
}

notInVector <- function(item, set) {
    .Call('_memnetr_notInVector', PACKAGE = 'memnetr', item, set)
}

staSearch2 <- function(x) {
    .Call('_memnetr_staSearch2', PACKAGE = 'memnetr', x)
}

split_stringlist <- function(sents, indices) {
    .Call('_memnetr_split_stringlist', PACKAGE = 'memnetr', sents, indices)
}

in_doc <- function(doc, term, space = TRUE) {
    .Call('_memnetr_in_doc', PACKAGE = 'memnetr', doc, term, space)
}

count_in_doc <- function(doc, term, space = TRUE) {
    .Call('_memnetr_count_in_doc', PACKAGE = 'memnetr', doc, term, space)
}

td_unit <- function(docs, terms) {
    .Call('_memnetr_td_unit', PACKAGE = 'memnetr', docs, terms)
}

td_count <- function(docs, terms) {
    .Call('_memnetr_td_count', PACKAGE = 'memnetr', docs, terms)
}

tt_unit <- function(td_mat) {
    .Call('_memnetr_tt_unit', PACKAGE = 'memnetr', td_mat)
}

tt_count <- function(td_mat) {
    .Call('_memnetr_tt_count', PACKAGE = 'memnetr', td_mat)
}

remove_rows <- function(mat, remove) {
    .Call('_memnetr_remove_rows', PACKAGE = 'memnetr', mat, remove)
}

combine_rows <- function(mat, inds, method = "max") {
    .Call('_memnetr_combine_rows', PACKAGE = 'memnetr', mat, inds, method)
}

triangle_ineq <- function(x) {
    .Call('_memnetr_triangle_ineq', PACKAGE = 'memnetr', x)
}

cnt_tokens <- function(words) {
    .Call('_memnetr_cnt_tokens', PACKAGE = 'memnetr', words)
}

